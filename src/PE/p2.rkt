#lang racket
(require memoize)
;;Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

;; 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

;; By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

;; This is just 1d dynamic programming with some guard clauses

(define fibs (hash 0 1 1 1 2 2))


;; (define (pack h acc n)
;;   (let* ([n-1 (hash-ref h (- n 1))]
;;          [n-2 (hash-ref h (- n 2))])
;;     (cond
;;       [()])))

(define (nth_ h n)
  (cond
    [(< n 1) (list h (hash-ref h 1))]
    [(hash-has-key? h n) (list h (hash-ref h n))]
    [else
     (let* ([h (first (nth_ h (- n 1)))]
            [n-2 (second (nth_ h (- n 2)))]
            [n-1 (hash-ref h (- n 1))]
            [h (hash-set h n (+ n-1 n-2))])
       (list h (hash-ref h n)))]))

;; non memoized for time comparison
(define (fib n)
  (if (<= n 1) 1 (+ (fib (- n 1)) (fib (- n 2)))))

(define (nth h n) (second (nth_ h n)))

;; brute force method, the better way would be to calculate the term that is
;; just < 4 mil, then pass that DP table around to generate the list, then fold

;; just going to switch to haskell, im just doing worse fp in racket at this point
